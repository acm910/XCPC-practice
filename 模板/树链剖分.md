# 树链剖分

## 求LCA

```c++
int fa[N];  
int depth[N];
int son[N];  //重儿子
int sz[N]; //子树大小
int top[N]; //重链的头

function<void(int,int,int)> dfs=[&](int x,int pa,int d)->void {
    fa[x] = pa;
    sz[x] = 1;
    depth[x] = d;
    for(int y:graph[x]){
        if(y == pa) continue;
        dfs(y,x,d+1);
        sz[x] += sz[y];
        if(sz[son[x]] < sz[y]) son[x] = y;
    }
};
dfs(1,-1,1);
function <void(int,int)> dfs1 =[&](int x,int t)->void{
    top[x] = t;
    if(son[x] == 0) return;
    dfs1(son[x],t);
    for(int y : graph[x]){
        if(y == fa[x] || y == son[x]) continue;
        dfs1(y,y);
    }
};
dfs1(1,1);
auto lca = [&](int x,int y)->int{
    while(top[x] != top[y]){
        if(depth[top[x]] > depth[top[y]]) swap(x,y);
        y = fa[top[y]];
    }
    return depth[x] < depth[y]?x:y;
};
```

## P3384 【模板】重链剖分/树链剖分

## 题目描述

如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：

- `1 x y z`，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。

- `2 x y`，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。

- `3 x z`，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。

- `4 x`，表示求以 $x$ 为根节点的子树内所有节点值之和。

## 输入格式

第一行包含 $4$ 个正整数 $N,M,R,P$，分别表示树的结点个数、操作个数、根节点序号和取模数（**即所有的输出结果均对此取模**）。

接下来一行包含 $N$ 个非负整数，分别依次表示各个节点上初始的数值。

接下来 $N-1$ 行每行包含两个整数 $x,y$，表示点 $x$ 和点 $y$ 之间连有一条边（保证无环且连通）。

接下来 $M$ 行每行包含若干个正整数，每行表示一个操作。

## 输出格式

输出包含若干行，分别依次表示每个操作 $2$ 或操作 $4$ 所得的结果（**对 $P$ 取模**）。

## 输入输出样例 #1

### 输入 #1

```
5 5 2 24
7 3 7 8 0 
1 2
1 5
3 1
4 1
3 4 2
3 2 2
4 5
1 5 1 3
2 1 3
```

### 输出 #1

```
2
21
```

## 说明/提示

**【数据规模】**

对于 $30\%$ 的数据： $1 \leq N \leq 10$，$1 \leq M \leq 10$；

对于 $70\%$ 的数据： $1 \leq N \leq {10}^3$，$1 \leq M \leq {10}^3$；

对于 $100\%$ 的数据： $1\le N \leq {10}^5$，$1\le M \leq {10}^5$，$1\le R\le N$，$1\le P \le 2^{30}$。所有输入的数均在 `int` 范围内。

**【样例说明】**

树的结构如下：

![](https://cdn.luogu.com.cn/upload/pic/2319.png)

各个操作如下：

![](https://cdn.luogu.com.cn/upload/pic/2320.png)

故输出应依次为 $2$ 和 $21$。

```en
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> PII;
typedef pair<LL,LL> PLL;

const int N = (int)1e5+5;
vector<int> graph[N];
LL arr[N];
LL MOD;

int fa[N];
int depth[N];
int sz[N];
int son[N];
int top[N];
int tag[N];
LL val[N];
#define root tree[o]
#define lc tree[o*2]
#define rc tree[o*2+1]
struct segTree{

    int l,r;
    LL val,lazy;
} tree[4*N];

void pushUp(int o){
    root.val = (lc.val + rc.val) %MOD;
}
void pushDown(int o) {
    if (root.lazy == 0) return;
    LL temp = root.lazy;
    root.lazy = 0;
    if (root.l == root.r) return;
    lc.val = (lc.val + 1ll * (lc.r - lc.l + 1) * temp % MOD) % MOD;
    rc.val = (rc.val + 1ll * (rc.r - rc.l + 1) * temp % MOD) % MOD;
    lc.lazy = (lc.lazy + temp) % MOD;
    rc.lazy = (rc.lazy + temp) % MOD;
}

void build(int o,int l,int r){
    root.l = l;
    root.r = r;
    root.lazy = 0;
    if(l == r){
        root.val = val[r];
        return;
    }
    int mid = (l+r) >> 1;
    build(o*2,l,mid);
    build(o*2+1,mid+1,r);
    pushUp(o);
}

void update(int o,int L,int R,LL v){
    if(root.l>= L && root.r <= R){
        root.val = (1ll*v*(root.r-root.l+1)%MOD + root.val)%MOD;
        root.lazy = (root.lazy +  v) %MOD;
        return;
    }
    pushDown(o);
    int mid = (root.l+root.r)>>1;
    if(mid >= L) update(o*2,L,R,v);
    if(mid < R) update(o*2+1,L,R,v);
    pushUp(o);
}

LL query(int o,int L,int R){
    if(root.l>= L && root.r <= R){
        return root.val;
    }
    pushDown(o);
    LL res = 0;
    int mid = (root.l+root.r)>>1;
    if(mid >= L) res = (res + query(o*2,L,R)) % MOD;
    if(mid < R) res = (res + query(o*2+1,L,R)) %MOD;
    return res;
}

void update_lian(int x,int y,LL v){
    while(top[x] != top[y]){
        if(depth[top[x]] > depth[top[y]]) swap(x,y);
        update(1,tag[top[y]],tag[y],v);
        y = fa[top[y]];
    }
    if(depth[x] > depth[y]) swap(x,y);
    update(1,tag[x],tag[y],v);
}


void update_tree(int x,LL v){
    update(1,tag[x],tag[x] + sz[x] -1,v);
}

LL query_lian(int x,int y){
    LL res = 0 ;
    while(top[x] != top[y]){
        if(depth[top[x]] > depth[top[y]]) swap(x,y);
        res = (res + query(1,tag[top[y]],tag[y]))%MOD;
        y = fa[top[y]];
    }
    if(depth[x] > depth[y]) swap(x,y);
    res = (res + query(1,tag[x],tag[y])) %MOD;
    return res;
}

LL query_tree(int x){
    return query(1,tag[x],tag[x] + sz[x]-1);
}

void solve(){
    int n,m,r;
    cin>>n>>m>>r>>MOD;
    for(int i = 1;i <=n;i++){
        cin>>arr[i];
    }
    for(int i = 1;i< n;i++){
        int u,v;
        cin>>u>>v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    function<void(int,int,int)> dfs1 = [&](int x,int d,int pa){
        fa[x] = pa;
        depth[x] = d;
        sz[x] = 1;
        for(int y : graph[x]){
            if(y == pa) continue;
            dfs1(y,d+1,x);
            sz[x] += sz[y];
            if(sz[son[x]] < sz[y]) son[x] = y;
        }
    };
    dfs1(r,1,-1);

    int tt = 0;
    function<void(int,int)> dfs2 = [&](int x,int t){
        top[x] = t;
        tag[x] = ++tt;
        val[tt] = arr[x];
        if(son[x] == 0) return;
        dfs2(son[x],t);
        for(int y:graph[x]){
            if(y == son[x] || y == fa[x]) continue;
            dfs2(y,y);
        }
    };
    dfs2(r,r);
    build(1,1,n);
    while(m--){
        int op;
        cin>>op;
        int x,y;
        LL z;
        if(op == 1){
            cin>>x>>y>>z;
            update_lian(x,y,z);
        }else if(op == 2){
            cin>>x>>y;
            LL res = query_lian(x,y) % MOD;
            cout<<res<<"\n";
        }else if(op == 3){
            cin>>x>>z;
            update_tree(x,z);
        }else if(op == 4){
            cin>>x;
            LL res = query_tree(x)%MOD;
            cout<<res<<"\n";
        }
    }

}


int main(){
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios::sync_with_stdio(false);
    int  tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }
}
```