# 树链剖分

求LCA

```
int fa[N];  
int depth[N];
int son[N];  //重儿子
int sz[N]; //子树大小
int top[N]; //重链的头

function<void(int,int,int)> dfs=[&](int x,int pa,int d)->void {
    fa[x] = pa;
    sz[x] = 1;
    depth[x] = d;
    for(int y:graph[x]){
        if(y == pa) continue;
        dfs(y,x,d+1);
        sz[x] += sz[y];
        if(sz[son[x]] < sz[y]) son[x] = y;
    }
};
dfs(1,-1,1);
function <void(int,int)> dfs1 =[&](int x,int t)->void{
    top[x] = t;
    if(son[x] == 0) return;
    dfs1(son[x],t);
    for(int y : graph[x]){
        if(y == fa[x] || y == son[x]) continue;
        dfs1(y,y);
    }
};
dfs1(1,1);
auto lca = [&](int x,int y)->int{
    while(top[x] != top[y]){
        if(depth[top[x]] > depth[top[y]]) swap(x,y);
        y = fa[top[y]];
    }
    return depth[x] < depth[y]?x:y;
};
```