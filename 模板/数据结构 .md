# 线段树

## 模板题

## P3372 【模板】线段树 1

## 题目描述

如题，已知一个数列 $\{a_i\}$，你需要进行下面两种操作：

1. 将某区间每一个数加上 $k$。
2. 求出某区间每一个数的和。

## 输入格式

第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。

第二行包含 $n$ 个用空格分隔的整数 $a_i$，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：

1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。
2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。

## 输出格式

输出包含若干行整数，即为所有操作 2 的结果。

## 输入输出样例 #1

### 输入 #1

```
5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4
```

### 输出 #1

```
11
8
20
```

## 说明/提示

对于 $15\%$ 的数据：$n \le 8$，$m \le 10$。  
对于 $35\%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。    
对于 $100\%$ 的数据：$1 \le n, m \le {10}^5$，$a_i,k$ 为正数，且任意时刻数列的和不超过 $2\times 10^{18}$。

**【样例解释】**

![](https://cdn.luogu.com.cn/upload/pic/2251.png)

## AC代码

```
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = (int)1e5+5;
LL segTree[4*N];
LL arr[N];
LL lazy[4*N];

void pushDown(int o,int l,int r){
    if(lazy[o] == 0) return;

    LL temp = lazy[o];
    lazy[o] = 0;
    if(l == r)return;
    int mid = (l+r)>>1;
    lazy[o*2] += temp;
    segTree[o*2] += temp*(mid-l+1);
    lazy[o*2+1] += temp;
    segTree[o*2+1] += temp*(r-mid);
}
void pushUp(int o){
    segTree[o] = segTree[o*2] + segTree[o*2+1];
}

//update for [L,R]
void update(int o,int l,int r,int L,int R,LL val){
    if(l>= L && r <= R){
        segTree[o] += val*(r-l+1);
        lazy[o] += val;
        return;
    }
    pushDown(o,l,r);
    int mid = (l+r)>>1;
    if(mid >= L){
        update(o*2,l,mid,L,R,val);
    }
    if(mid+1 <=R){
        update(o*2+1,mid+1,r,L,R,val);
    }
    pushUp(o);
}





LL query(int o,int l,int r,int L,int R){

    if(l >= L && r <= R){
        return segTree[o];
    }
    pushDown(o,l,r);
    LL res =0 ;
    int mid = (l+r)>>1;
    if(mid + 1 <= R ) res += query(o*2+1,mid+1,r,L,R);
    if(mid >= L) res += query(o*2,l,mid,L,R);
    return res;
}

void solve(){
    int n,m;
    cin>>n>>m;
    fill(segTree,segTree+4*n+1,0);
    fill(lazy,lazy+4*n+1,0);
    for(int i =1;i<=n;i++){
        cin>>arr[i];
        update(1,1,n,i,i,arr[i]);
    }
    while(m--){
        int d;
        cin>>d;
        if(d == 1){
            int x,y;
            LL k;
            cin>>x>>y>>k;
            update(1,1,n,x,y,k);
        }else if(d == 2){
            int x,y;
            cin>>x>>y;
            cout<<query(1,1,n,x,y)<<"\n";

        }
    }
}
int main(){
    cin.tie(0);cout.tie(0);
    ios::sync_with_stdio(false);
    int tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }

}
```

# P3373 【模板】线段树 2

## 题目描述

如题，已知一个数列 $a$，你需要进行下面三种操作：

- 将某区间每一个数乘上 $x$；
- 将某区间每一个数加上 $x$；
- 求出某区间每一个数的和。

## 输入格式

第一行包含三个整数 $n,q,m$，分别表示该数列数字的个数、操作的总个数和模数。

第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值 $a_i$。

接下来 $q$ 行每行包含若干个整数，表示一个操作，具体如下：

操作 $1$： 格式：`1 x y k`  含义：将区间 $[x,y]$ 内每个数乘上 $k$。

操作 $2$： 格式：`2 x y k`  含义：将区间 $[x,y]$ 内每个数加上 $k$。

操作 $3$： 格式：`3 x y`  含义：输出区间 $[x,y]$ 内每个数的和对 $m$ 取模所得的结果。

## 输出格式

输出包含若干行整数，即为所有操作 $3$ 的结果。

## 输入输出样例 #1

### 输入 #1

```
5 5 38
1 5 4 2 3
2 1 4 1
3 2 5
1 2 4 2
2 3 5 5
3 1 4
```

### 输出 #1

```
17
2
```

## 说明/提示

【数据范围】

对于 $30\%$ 的数据：$n \le 8$，$q \le 10$。  
对于 $70\%$ 的数据：$n \le 10^3 $，$q \le 10^4$。  
对于 $100\%$ 的数据：$1 \le n \le 10^5$，$1 \le q \le 10^5,1\le a_i,k\le 10^4$。

除样例外，$m = 571373$。

（数据已经过加强 ^\_^）

样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2255.png) 

故输出应为 $17$、$2$（$40 \bmod 38 = 2$）。

## AC代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> PII;

const int N = (int)1e5 + 5;
int arr[N];

struct segTree{
    LL tree[4*N];
    LL lazy[4*N];
    LL mulLazy[4*N];
} sTree;


void pushUp(int o ,LL mod){
    sTree.tree[o] = (sTree.tree[o*2] + sTree.tree[o*2+1])%mod;
}

void pushDown(int o,int l,int r,LL mod){
    LL temp = sTree.lazy[o];
    LL temp2 = sTree.mulLazy[o];
    sTree.lazy[o] = 0;
    sTree.mulLazy[o] = 1;
    if(l == r)return;


    int mid = (l+r)>>1;
    sTree.tree[o*2] = (sTree.tree[o*2]*temp2)%mod;
    sTree.tree[o*2+1] = (sTree.tree[o*2+1]*temp2)%mod;
    sTree.lazy[o*2] = (sTree.lazy[o*2]*temp2)%mod;
    sTree.lazy[o*2+1] = (sTree.lazy[o*2+1]*temp2)%mod;
    sTree.mulLazy[o*2] = (sTree.mulLazy[o*2] * temp2)%mod;
    sTree.mulLazy[o*2+1] = (sTree.mulLazy[o*2+1] * temp2)%mod;

    sTree.tree[o*2] = (sTree.tree[o*2]+1ll*(mid-l+1)*temp)%mod;
    sTree.tree[o*2+1] = (sTree.tree[o*2+1] +1ll * (r- mid) *temp)%mod;
    sTree.lazy[o*2] = (sTree.lazy[o*2]+temp)%mod;
    sTree.lazy[o*2+1] = (sTree.lazy[o*2+1]+temp)%mod;

}

void updateSum(int o,int l,int r,int L,int R,LL val,LL mod){
    if(l >= L && r<=R){
        sTree.tree[o] = (sTree.tree[o]+1ll*(r-l+1) * val)%mod;
        sTree.lazy[o] = (sTree.lazy[o]+val)%mod;
        return;
    }
    pushDown(o,l,r,mod);
    int mid =(l+r)>>1;
    if(mid >= L) updateSum(o*2,l,mid,L,R,val,mod);
    if(mid +1 <=R)updateSum(o*2+1,mid+1,r,L,R,val,mod);
    pushUp(o ,mod);
}

void updateMul(int o,int l,int r,int L,int R,LL val,LL mod){
    if(l >= L && r<=R){
        sTree.tree[o] = (sTree.tree[o] * val)%mod;
        sTree.lazy[o] = (sTree.lazy[o] * val)%mod;
        sTree.mulLazy[o] = (sTree.mulLazy[o] * val)%mod;
        return;
    }
    pushDown(o,l,r,mod);
    int mid =(l+r)>>1;
    if(mid >= L) updateMul(o*2,l,mid,L,R,val,mod);
    if(mid +1 <=R)updateMul(o*2+1,mid+1,r,L,R,val,mod);
    pushUp(o,mod);
}

LL query(int o,int l,int r,int L,int R,LL mod){
    LL res = 0;
    if(l>=L && r<=R){
        return sTree.tree[o]%mod;
    }
    pushDown(o,l,r,mod);
    int mid = (l+r)>>1;
    if(mid >=L){
        res =  (res + query(o*2,l,mid,L,R,mod)) %mod;
    }if(mid + 1<=R){
        res = (res + query(o*2+1,mid+1,r,L,R,mod))%mod;
    }
    return res;

}

void solve(){
    int n,q,m;
    fill(sTree.mulLazy,4*N+sTree.mulLazy,1);
    cin>>n>>q>>m;
    for(int i = 1;i<=n;i++){
        cin>>arr[i];
        updateSum(1,1,n,i,i,arr[i],m);
    }
    while(q--){
        int state;
        cin>>state;
        if(state == 1){
            int x,y;
            LL k;
            cin>>x>>y>>k;
            updateMul(1,1,n,x,y,k,m);
        }else if(state ==2){
            int x,y;
            LL k;
            cin>>x>>y>>k;
            updateSum(1,1,n,x,y,k,m);
        }else if(state ==3){
            int x,y;
            cin>>x>>y;
            LL res = query(1,1,n,x,y,m);
            cout<<res<<"\n";
        }
    }


}

int main(){
    cin.tie(0);cout.tie(0);
    ios::sync_with_stdio(false);
    int tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }
    return 0;
}
```

