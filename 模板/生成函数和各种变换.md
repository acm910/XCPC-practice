# FFT

## P3803 【模板】多项式乘法（FFT）

## 题目背景

这是一道多项式乘法模板题。

注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。

## 题目描述

给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$。

请求出 $F(x)$ 和 $G(x)$ 的乘积。

## 输入格式

第一行两个整数 $n,m$。

接下来一行 $n+1$ 个数字，从低到高表示 $F(x)$ 的系数。

接下来一行 $m+1$ 个数字，从低到高表示 $G(x)$ 的系数。

## 输出格式

一行 $n+m+1$ 个数字，从低到高表示 $F(x) \cdot G(x)$ 的系数。

## 输入输出样例 #1

### 输入 #1

```
1 2
1 2
1 2 1
```

### 输出 #1

```
1 4 5 2
```

## 说明/提示

保证输入中的系数大于等于 $0$ 且小于等于 $9$。

对于 $100\%$ 的数据：$1 \le n, m \leq {10}^6$。

## AC代码

### 递归法：

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef  pair<LL,LL> PLL;
typedef  pair<int,int> PII;
LL MOD = (LL)1e9+7;
double eps = 1e-9;
LL INF = (LL)1e9;
const int N = (int)3e6+10;



struct cNum{
    double a,b;
} arr[N],brr[N];
cNum operator +(cNum c1,cNum c2){
    cNum ans{};
    ans.a = c1.a+c2.a;
    ans.b = c1.b+c2.b;
    return ans;
}
cNum operator -(cNum c1,cNum c2){
    cNum ans{};
    ans.a = c1.a-c2.a;
    ans.b = c1.b-c2.b;
    return ans;
}
cNum operator *(cNum c1,cNum c2){
    cNum ans{};
    ans.a = c1.a*c2.a -c1.b*c2.b;
    ans.b = c1.b*c2.a + c1.a*c2.b;
    return ans;
}

void FFT(int limit ,cNum* a ,int type){
    if(limit == 1)return;
    cNum a1[limit>>1],a2[limit>>1];
    for(int i = 0 ; i< limit;i+=2){
        a1[i>>1] = a[i],a2[i>>1] = a[i+1];
    }
    FFT(limit>>1,a1,type);
    FFT(limit>>1,a2,type);
    cNum Wn = {cos(2.0*M_PI/limit),sin(2.0*M_PI/limit)*type};
    cNum W = {1,0};
    for(int i =0 ; i < (limit>>1);i++,W = W*Wn){
        a[i] = a1[i] + W*a2[i];
        a[i+(limit>>1)] = a1[i] - W*a2[i];
    }
}

void solve(){
    int n,m;
    cin>>n>>m;
    double x;
    int limit = 1;
    for(;limit <= n+m ; limit *= 2);
    for(int i =0 ; i <= n ;i++){
        cin>>x;
        arr[i] = {x,0};
    }
    for(int i =0 ; i <= m ;i++){
        cin>>x;
        brr[i] = {x,0};
    }
    FFT(limit,arr,1);
    FFT(limit,brr,1);
    for(int i =0 ; i < limit;i++){
        arr[i] = arr[i] * brr[i];
    }
    FFT(limit,arr,-1);
    for(int i =0  ;i <= n+m ;i++){
        cout<<(int)(arr[i].a/limit+0.5)<<" ";
    }

}


int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }
}
```

### 分治法（速度更快）

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef  pair<LL,LL> PLL;
typedef  pair<int,int> PII;
LL MOD = (LL)1e9+7;
double eps = 1e-9;
LL INF = (LL)1e9;
const int N = (int)3e6+10;



struct cNum{
    double a,b;
} arr[N],brr[N];
cNum operator +(cNum c1,cNum c2){
    cNum ans{};
    ans.a = c1.a+c2.a;
    ans.b = c1.b+c2.b;
    return ans;
}
cNum operator -(cNum c1,cNum c2){
    cNum ans{};
    ans.a = c1.a-c2.a;
    ans.b = c1.b-c2.b;
    return ans;
}
cNum operator *(cNum c1,cNum c2){
    cNum ans{};
    ans.a = c1.a*c2.a -c1.b*c2.b;
    ans.b = c1.b*c2.a + c1.a*c2.b;
    return ans;
}

int l,r[N];

void FFT(int limit ,cNum* a ,int type){
    for(int i=0;i<limit;i++)
        if(i<r[i]) swap(a[i],a[r[i]]);//求出要迭代的序列
    for(int mid=1;mid<limit;mid<<=1)//待合并区间的中点
    {
        cNum Wn = { cos(M_PI/mid) , type*sin(M_PI/mid) }; //单位根
        for(int R=mid<<1,j=0;j<limit;j+=R)
        {
            cNum w = {1,0};//幂
            for(int k=0;k<mid;k++,w=w*Wn)//枚举左半部分
            {
                cNum x=a[j+k],y=w*a[j+mid+k];//蝴蝶效应
                a[j+k]=x+y;
                a[j+mid+k]=x-y;
            }
        }
    }
    
}

void solve(){
    int n,m;
    cin>>n>>m;
    double x;
    int limit = 1;
    l = 0;
    for(;limit <= n+m ; limit *= 2,l++);
    for(int i =0 ; i <= n ;i++){
        cin>>x;
        arr[i] = {x,0};
    }
    for(int i =0 ; i <= m ;i++){
        cin>>x;
        brr[i] = {x,0};
    }
    for(int i=0;i<limit;i++)
        r[i]= ( r[i>>1]>>1 )| ( (i&1)<<(l-1) ) ;
    FFT(limit,arr,1);
    FFT(limit,brr,1);
    for(int i =0 ; i < limit;i++){
        arr[i] = arr[i] * brr[i];
    }
    FFT(limit,arr,-1);
    for(int i =0  ;i <= n+m ;i++){
        cout<<(int)(arr[i].a/limit+0.5)<<" ";
    }

}


int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }
}
```



## NTT

题目与FTT一致，仅是使用数论方法替换点值表示时的选点

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const LL P = 998244353;   // 模数
const LL G = 3;          // 原根
const LL Gi = 332748118; // 原根的逆元
const int MAXN = 8400010; // 足够大的数组空间（适应2^23长度）

int r[MAXN];             // 蝴蝶变换数组
LL a[MAXN], b[MAXN];     // 多项式系数数组
int n, m, limit, L;      // 多项式次数/长度/幂次

// 快速幂 (模P)
inline LL fastpow(LL a, LL k) {
    LL res = 1;
    a %= P;
    while(k) {
        if(k & 1) res = (res * a) % P;
        a = (a * a) % P;
        k >>= 1;
    }
    return res;
}

// NTT变换函数
inline void NTT(LL *A, int type) {
    // 蝴蝶交换
    for(int i = 0; i < limit; i++)
        if(i < r[i]) swap(A[i], A[r[i]]);
    
    // 分治过程
    for(int mid = 1; mid < limit; mid <<= 1) {
        // 计算单位根 Wn = (type==1) ? G^(P-1)/(2*mid) : Gi^(P-1)/(2*mid)
        LL Wn = fastpow(type == 1 ? G : Gi, (P - 1) / (mid << 1));
        
        // 遍历每个分块
        for(int j = 0; j < limit; j += (mid << 1)) {
            LL w = 1;
            // 遍历当前分块的元素
            for(int k = 0; k < mid; k++, w = (w * Wn) % P) {
                LL x = A[j + k], y = w * A[j + k + mid] % P;
                A[j + k] = (x + y) % P;
                A[j + k + mid] = (x - y + P) % P;
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> m;
    // 读入多项式a和b的系数
    for(int i = 0; i <= n; i++) cin >> a[i];
    for(int i = 0; i <= m; i++) cin >> b[i];
    
    // 初始化变换长度limit和幂次L
    limit = 1, L = 0;
    while(limit <= n + m) {
        limit <<= 1;
        L++;
    }
    
    // 初始化蝴蝶变换数组r
    for(int i = 0; i < limit; i++)
        r[i] = (r[i >> 1] >> 1) | ((i & 1) << (L - 1));
    
    // 正变换
    NTT(a, 1);
    NTT(b, 1);
    
    // 点乘
    for(int i = 0; i < limit; i++) 
        a[i] = (a[i] * b[i]) % P;
    
    // 逆变换
    NTT(a, -1);
    
    // 计算逆元（用于归一化）
    LL inv = fastpow(limit, P - 2);
    
    // 输出结果多项式系数
    for(int i = 0; i <= n + m; i++)
        cout << (a[i] * inv) % P << " ";
    
    return 0;
}
```

### 模数 (P) 的选择要求

1. **必须是质数**：模数 P 必须是质数，这样才能保证在模 P 下存在原根

2. **满足 P = c·2^k + 1**：其中 k 要足够大（至少大于 log₂(多项式长度)），这样才能支持足够大的变换长度

3. 

   常见模数示例：

   - 998244353 = 119×2²³ + 1 (k=23)
   - 1004535809 = 479×2²¹ + 1 (k=21)
   - 469762049 = 7×2²⁶ + 1 (k=26)

### 原根 (G) 的选择要求

1. **必须是模 P 的原根**：即 G 在模 P 下的阶为 P-1

2. **Gi 是 G 的逆元**：Gi = G⁻¹ mod P

3. 

   常见模数对应的原根：

   - P=998244353 时，G=3，Gi=332748118
   - P=1004535809 时，G=3，Gi=334845270
   - P=469762049 时，G=3，Gi=156587350

### 使用注意事项

1. **系数范围**：多项式系数必须在 [0, P-1] 范围内
2. **变换长度**：最大变换长度受限于 k（P = c·2^k + 1 中的 k）
3. **精度问题**：NTT 避免了浮点数运算，没有精度损失
4. **效率**：NTT 在模运算下进行，比 FFT 的浮点运算稍慢





# FWT

块速沃尔什变换

## P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)

### 题目描述

给定长度为 $2^n$ 两个序列 $A,B$，设 

$$C_i=\sum_{j\oplus k = i}A_j \times B_k$$

分别当 $\oplus$ 是 or, and, xor 时求出 $C$。

### 输入格式

第一行，一个整数 $n$。  
第二行，$2^n$ 个数 $A_0, A_1, \ldots, A_{2^n-1}$。  
第三行，$2^n$ 个数 $B_0, B_1, \ldots, B_{2^n-1}$。

## 输出格式

三行，每行 $2^n$ 个数，分别代表 $\oplus$ 是 or, and, xor 时 $C_0, C_1, \ldots, C_{2^n-1}$ 的值 $\bmod\ 998244353$。

## 输入输出样例 #1

### 输入 #1

```
2
2 4 6 8
1 3 5 7
```

### 输出 #1

```
2 22 46 250
88 64 112 56
100 92 68 60
```

## 说明/提示

$1 \le n \le 17$。