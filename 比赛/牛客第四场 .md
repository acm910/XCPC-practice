# D Determinant of 01-Matrix

时间限制：C/C++/Rust/Pascal 2秒，其他语言4秒
空间限制：C/C++/Rust/Pascal 1024 M，其他语言2048 M
Special Judge, 64bit IO Format: %lld

## 题目描述 

Given a positive integer N≤109, please construct a matrix A=(ai,j)1≤i,j≤n*A*=(*a**i*,*j*)1≤*i*,*j*≤*n* that contains only 00s and 11s, satisfying

1. 1≤n≤2001≤*n*≤200;
2. det(A)=Ndet(*A*)=*N*.

It is guaranteed that there exists a valid solution under the problem constraints.

## 输入描述:

```
The input contains only one positive integer NN (1≤N≤1091≤N≤109).
```

## 输出描述:

```
The output should contain a first line with a positive integer nn (1≤n≤2001≤n≤200), indicating the size of the constructed matrix.

Next, output nn lines, where the ii-th line contains nn integers ai,1,ai,2,…,ai,nai,1,ai,2,…,ai,n (ai,j∈{0,1}ai,j∈{0,1}), representing the elements of the ii-th row of the matrix. If there are multiple solutions, any one of them can be output.
```

示例1

## 输入

```
1
```

## 输出

```
1
1
```

示例2

## 输入

```
5
```

## 输出

```
7
0 0 0 1 0 0 1
0 0 1 0 0 1 0
0 1 1 0 0 0 1
0 1 0 1 1 0 0
1 1 0 1 1 1 0
1 1 1 1 0 0 0
1 1 1 0 1 0 0
```

## AC代码

构造思路：先构造一个（1,1,1....n）的对角矩阵，再在最后一列上面每两行增加一个$-\lfloor\frac{n}{2}\rfloor$的元素，并再第一行加一个1，通过矩阵变换使得最终矩阵中所有元素都为1，有变换性质可知这样变换行列式的值不变.

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> PII;
const int N = 196;
int ans[N][N];
void solve(){
    int n;
    cin>>n;
    for(int i = 0;i<N;i++){
        for(int j = 0 ; j < N;j++){
            ans[i][j] = 0;
            if(i == j) ans[i][j] =1;
        }
    }
    ans[N-1][N-1] = n;
    ans[0][N-1] = 1;
    for(int i = N-2 ;i >= 0;i-=2){
        n /= -2;
        if(n == 0) break;
        ans[i][N-1] = n;
        ans[i-1][N-1] = n;
    }
    for(int i = N-1;i >= 0;i--){
        if(ans[i][N-1] != 0 && ans[i][N-1] != 1){
            int line = ((i+1)/2-1)*2;
            for(int j = 0; j<N;j++){
                ans[i][j] += ans[line-1][j] + ans[line][j];
            }
            if(ans[i][N-1] == -1){
                for(int j = 0; j < N;j++){
                    ans[i][j] += ans[0][j];
                }
            }
        }
    }
    cout<<N<<"\n";
    for(int i = 0; i < N;i++){
        for(int j = 0; j < N;j++){
            cout<<ans[i][j]<<" ";
        }
        cout<<"\n";
    }
}


int main(){
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios::sync_with_stdio(false);
    int tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }
}
```







# E Echoes of 24

**Please note the special memory limit of this problem.**

![img](https://uploadfiles.nowcoder.com/images/20250708/0_1751963254497/F51C29794E630AF10DD08BC2804348B9)

This is Tachibana Kanade. She is very cute.

In the quiet afterlife, where forgotten memories echo like distant bells, a vast Tree connects every soul's regret.

Tachibana Kanade, the silent guardian, awakens in the center of this realm. Each node on the Tree holds a number ai*a**i* --- fragments of emotion, unresolved wishes, and fading light.

To awaken her scattered friends, Kanade must walk from node l*l* to node r*r*, tracing a simple path. The values along this path are w1,w2,…,wk*w*1,*w*2,…,*w**k*. She starts with the counter set to w1*w*1.

At each of the next k−1*k*−1 steps, she will:

∙∙ Increase the step index by 1,
∙∙ Choose to either **add** or **multiply** the counter by the current value wid*w**i**d*​.

Her mission: reach exactly 2424, the number that symbolizes a complete day --- 24 hours of precious time, 24 echoes of unspoken memories.

Some queries ask whether such a path can yield 24. Others alter the memory fragments themselves.

Can Kanade rewrite fate and reach that quiet resolution once more?Echoes of 24

## 输入描述:

```
The first line contains two integers nn and qq (1≤n,q≤5×105)(1≤n,q≤5×105) --- the number of nodes in the tree and the number of queries.

The second line contains nn integers a1,a2,…,an(1≤ai≤109)a1,a2,…,an(1≤ai≤109) --- the memory values stored at each node.

Then follow n−1n−1 lines, each containing two integers uu and vv --- indicating an undirected edge between nodes uu and vv.


Then qq lines follow, each representing one of the following two types of queries:∘∘ 1 l r1 l r: check if path from ll to rr can yield 24,
∘∘ 2 x d2 x d: update value at node xx to dd.
```

## 输出描述:

```
For each query of type 1 l r1 l r, output one line:
∙∙ 11 if the path can reach value 24,
∙∙ 00 otherwise.
```

示例1

## 输入

[复制](javascript:void(0);)

```
9 8
1 3 1 2 4 6 5 2 2
1 2
1 3
2 4
2 5
3 6
3 7
6 8
7 9
1 4 8
1 4 9
1 2 8
1 6 9
1 9 6
2 3 8
1 6 9
1 9 6
```

## 输出

[复制](javascript:void(0);)

```
1
1
0
1
0
0
1
```

示例2

## 输入

[复制](javascript:void(0);)

```
8 8
3 2 3 3 1 3 1 2
2 1
3 2
4 1
5 2
6 4
7 6
8 7
2 4 4
1 8 2
2 5 2
1 2 4
1 5 2
2 1 3
1 4 8
2 6 2
```

## 输出

[复制](javascript:void(0);)

```
1
1
0
1
```

## 备注:

```
Constraints:
∙∙ 1≤n,q≤5×1051≤n,q≤5×105
∙∙ 1≤ai,d≤1091≤ai,d≤109

∙∙ 1≤l,r,x≤n1≤l,r,x≤n
```

## 思路：

​		树上问题，首先考虑链上问题（从特殊到一般）。

​		在一条链上存在n个结点，我们需要通过在节点之间加入$+$和$*$来使得答案为24。

​		思考暴力做法，我们可以用dp\[i\]\[j\]的数组记录到第i个节点时是否可以时答案变为j。这样需要O（24n）的时间和空间去验证。当n较大时，对于多次查询，时间复杂度显然不可接收，因此dp需要优化。

​		一个显然的结论，当链上的节点数更多，就越难使最终的答案到达24，我们可以从节点个数入手思考这个问题。

​		注意到性质：$a*b > a+b（a,b\geq2）$贪心的想，当节点值$x\geq2$时，我们更倾向于使用加法避免计算值超过24。如果都选择加法，那我们最多可以选择最多24个节点（及全为24）。

​		当节点数大于24时，我们需要考虑上面的性质，要是最后的结果尽可能小（以求得题目答案）我们应该将所有的1都是以*的形式贡献至答案之中，其他的节点以加的性质贡献到答案中。

​		如果发现这个贡献值大于24，我们便可以判断无法使得答案小于24。但当该值小与等于24时，我们只需要将部分1的贡献改为加法计入答案中，一定可以得到最终答案24。

​		因此，如果答案小于24时，我们可以用dp暴力计算方案的存在性，否则，通过上面的性质快速判断即可。

​		在链上，我们可以通过前缀和维护这一性质，及对每个元素的贡献视为$arr[i] >=2?arr[i]:0$,对其求前缀和，便可以快速求得链上子区间的最小贡献值。

​		将问题回到树上，我们需要考虑树上前缀和，题目需要修改某个节点的值，因此我们会对树上的该节点子树的前缀和进行修改，需要对单点进行查询，考虑使用dfs序和树状数组，可以完美解决这个问题。

​		总结，我们在查询时先找到两个节点之间的最短链（lca），判断链的长度是否大于等于24，如果大于24，通过判段该路径上的贡献和是否小于等于24，可用O(logn)的时间判断答案存在性。若长度小于24，我们可以使用暴力dp判断答案存在的可能性，时间复杂度为O（v*24）(v为链上节点的个数)。对于1e5的查询量，时间复杂度是满足要求的。



## 超空间做法（倍增求LCA+dfs序+树状数组）时间复杂度（O(n) + O（nlogn）+O(qlogn)）

```
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> PII;
const int N = 5e5+5;
const int LOG = 20;
bool dp[25][25]{false};

LL arr[N];
vector<int> graph[N];
int fa[N][LOG];
//int fa[N];
int depth[N];

int in[N];
int out[N];
vector<int> path;

LL tree[N];

int lowbit(int x){
    return x&(-x);
}

void update(int i,LL val){
    while(i < N){
        tree[i] += val;
        i += lowbit(i);
    }
}

LL query(int i){
    LL res =0 ;
    while(i){
        res += tree[i];
        i-= lowbit(i);
    }
    return res;
}

void solve(){
    int n,q;
    cin>>n>>q;
    for(int i =1 ; i <= n ;i++){
        cin>>arr[i];
    }
    depth[1] = 0;
    for(int i =1 ; i<= n-1 ;i++){
        int u,v;
        cin>>u>>v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    int tt =0 ;
    for(int i = 0; i< N;i++){
        for(int j =0 ; j < LOG;j++){
            fa[i][j] = -1;
        }
    }
    function<void(int,int,int)> dfs=[&](int x,int pa,int d)->void {
        fa[x][0] = pa;
        in[x] = ++tt;
        depth[x] = d;
        for(int y : graph[x]){
            if(y == pa) continue;
            dfs(y,x,d+1);
        }
        out[x] = tt;
    };
    dfs(1,-1,1);

    for(int j = LOG-1;j>0;j--) {
        for (int i = 1; i <= n; i++) {
            if(fa[i][j-1]!= -1){
                fa[i][j] = fa[fa[i][j-1]][j-1];
            }
        }
    }

    auto lca = [&](int x,int y){
        if(depth[x] > depth[y]){
            int temp = x;
            x = y ;
            y = temp;
        }
        for(int j = LOG-1;j >= 0;j--){
            if(depth[y] - depth[x] >= (1<<j) ){
                y = fa[y][j];
            }
        }
        if(x == y) return x;
        for(int j = LOG - 1;j>= 0 ;j--){
            if(depth[y] < (1<<j)) continue;
            if(fa[x][j] != fa[y][j]) {
                x = fa[x][j];
                y = fa[y][j];
            }
        }
        return fa[x][0];
    };

    function<void(int,int)> dfs2 = [&](int x,int pa)->void {
        update(in[x],arr[x]>=2?arr[x]:0);
        update(out[x] + 1,-(arr[x]>=2?arr[x]:0));
        for(int y : graph[x]){
            if(y != pa){
                dfs2(y,x);
            }
        }
    };
    dfs2(1,0);
    while(q--){
        int state;
        cin>>state;
        if(state == 1){
            int l,r;
            cin>>l>>r;
            int LCA = lca(l,r);
            int len = depth[l] + depth[r] - depth[LCA]*2+1;
            if(len >= 24){
                LL s = query(l) + query(r) - query(LCA) + (arr[LCA] >= 2 ? arr[LCA] : 0);
                if(s > 24){
                    cout<<"0\n";
                }else cout<<"1\n";
                continue;
            }else{
                int start = l;
                int end = r;
                path.clear();
                while(start!= LCA){
                    path.push_back(start);
                    start = fa[start][0];
                }
                path.push_back(LCA);
                int temp = path.size();
                while(end != LCA){
                    path.push_back(end);
                    end = fa[end][0];
                }
                reverse(path.begin()+temp,path.end());
                for(int i =0 ; i < 25;i++){
                    for(int j = 0; j<25;j++){
                        dp[i][j] = false;
                    }
                }
                dp[1][arr[path[0]]] = true;
                for(int i =2; i <=path.size()  ;i++){
                    int now = path[i-1];
                    for(int j =0 ;j<=24;j++){
                        if(j + arr[now] <=24){
                            dp[i][j+arr[now]] |= dp[i-1][j];
                        }
                        if(j * arr[now] <= 24){
                            dp[i][j*arr[now]] |= dp[i-1][j];
                        }
                    }
                }
                if(dp[path.size()][24]){
                    cout<<"1\n";
                }else{
                    cout<<"0\n";
                }
            }
        }else if(state == 2){
            int x;
            LL d;
            cin>>x>>d;
            update(in[x],-(arr[x]>=2?arr[x]:0));
            update(out[x],arr[x]>=2?arr[x]:0);
            arr[x] = d;
            update(in[x],arr[x]>=2?arr[x]:0);
            update(out[x] + 1,-(arr[x]>=2?arr[x]:0));
        }
    }
}


int main(){
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios::sync_with_stdio(false);
    int tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }
}
```

## AC代码（树链剖分LCA+dfs序+树状数组+局部dp）时间复杂度（O(n) + O(qlogn)）空间复杂度（O(n) + O(24*24)）

```
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> PII;
const int N = 5e5+5;
bool dp[25][25]{false};

LL arr[N];
vector<int> graph[N];

int fa[N];  
int depth[N];
int son[N];  //重儿子
int sz[N]; //子树大小
int top[N]; //重链的头

int in[N];  //dfs序
int out[N];  //dfs序
vector<int> path;

LL tree[N];

int lowbit(int x){
    return x&(-x);
}

void update(int i,LL val){
    while(i < N){
        tree[i] += val;
        i += lowbit(i);
    }
}

LL query(int i){
    LL res =0 ;
    while(i){
        res += tree[i];
        i-= lowbit(i);
    }
    return res;
}

void solve(){
    int n,q;
    cin>>n>>q;
    for(int i =1 ; i <= n ;i++){
        cin>>arr[i];
    }
    depth[1] = 0;
    for(int i =1 ; i<= n-1 ;i++){
        int u,v;
        cin>>u>>v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    int tt =0 ;  //时间戳
    fill(son,son+N,0);
    function<void(int,int,int)> dfs=[&](int x,int pa,int d)->void {
        fa[x] = pa;
        in[x] = ++tt;
        sz[x] = 1;
        depth[x] = d;
        for(int y:graph[x]){
            if(y == pa) continue;
            dfs(y,x,d+1);
            sz[x] += sz[y];
            if(sz[son[x]] < sz[y]) son[x] = y;
        }
        out[x] = tt;
    };
    dfs(1,-1,1);
    function <void(int,int)> dfs1 =[&](int x,int t)->void{
        top[x] = t;
        if(son[x] == 0) return;
        dfs1(son[x],t);
        for(int y : graph[x]){
            if(y == fa[x] || y == son[x]) continue;
            dfs1(y,y);
        }
    };
    dfs1(1,1);
    auto lca = [&](int x,int y)->int{
        while(top[x] != top[y]){
            if(depth[top[x]] > depth[top[y]]) swap(x,y);
            y = fa[top[y]];
        }
        return depth[x] < depth[y]?x:y;
    };

    function<void(int,int)> dfs2 = [&](int x,int pa)->void {
        update(in[x],arr[x]>=2?arr[x]:0);
        update(out[x] + 1,-(arr[x]>=2?arr[x]:0));
        for(int y : graph[x]){
            if(y != pa){
                dfs2(y,x);
            }
        }
    };
    dfs2(1,0);
    while(q--){
        int state;
        cin>>state;
        if(state == 1){
            int l,r;
            cin>>l>>r;
            int LCA = lca(l,r);
            int len = depth[l] + depth[r] - depth[LCA]*2+1;
            if(len >= 24){
                LL s = query(in[l]) + query(in[r]) - 2*query(in[LCA]) + (arr[LCA] >= 2 ? arr[LCA] : 0);
                if(s > 24){
                    cout<<"0\n";
                }else cout<<"1\n";
                continue;
            }else{
                int start = l;
                int end = r;
                path.clear();
                while(start!= LCA){
                    path.push_back(start);
                    start = fa[start];
                }
                path.push_back(LCA);
                int temp = path.size();
                while(end != LCA){
                    path.push_back(end);
                    end = fa[end];
                }
                reverse(path.begin()+temp,path.end());
                for(int i =0 ; i < 25;i++){
                    for(int j = 0; j<25;j++){
                        dp[i][j] = false;
                    }
                }
                dp[1][arr[path[0]]] = true;
                for(int i =2; i <=path.size()  ;i++){
                    int now = path[i-1];
                    for(int j =0 ;j<=24;j++){
                        if(j + arr[now] <=24){
                            dp[i][j+arr[now]] |= dp[i-1][j];
                        }
                        if(j * arr[now] <= 24){
                            dp[i][j*arr[now]] |= dp[i-1][j];
                        }
                    }
                }
                if(dp[path.size()][24]){
                    cout<<"1\n";
                }else{
                    cout<<"0\n";
                }
            }
        }else if(state == 2){
            int x;
            LL d;
            cin>>x>>d;
            update(in[x],-(arr[x]>=2?arr[x]:0));
            update(out[x]+1,arr[x]>=2?arr[x]:0);
            arr[x] = d;
            update(in[x],arr[x]>=2?arr[x]:0);
            update(out[x]+1,-(arr[x]>=2?arr[x]:0));
        }
    }
}


int main(){
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios::sync_with_stdio(false);
    int tt = 1;
    //cin>>tt;
    while(tt--){
        solve();
    }
}
```